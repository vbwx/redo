#!/bin/bash

version="2.1.1"

set -eu
shopt -s nullglob
IFS=$'\t\n'

function traverse {
	INDEX=0
	COUNT=$#
	((DEPTH)) || RCOUNT=$#
	[[ -n ${maxdepth-} && $DEPTH -eq $maxdepth ]] && return

	for d in "$@"; do
		((DEPTH)) || ((RINDEX++))
		((INDEX++))
		[[ $d != '/' ]] && d="${d%/}"
		if ! [[ -d $d ]]; then
			$quiet || echo "redo: ${CWD:+$CWD/}$d: no such directory" >&2
			continue
		fi
		! $follow && [[ -L $d ]] && continue
		if ! [[ -x $d && -r $d ]]; then
			$quiet || echo "redo: ${CWD:+$CWD/}$d: permission denied" >&2
			continue
		fi
		$nocwd || cd -- "$d"
		((DEPTH++))
		((RUNS++))

		if ((${#indir[@]})); then
			if $nocwd; then
				dirs=(${indir[@]/#/$d/})
			else
				dirs=(${indir[@]})
			fi
		else
			if $nocwd; then
				dirs=("$d"/*/)
			else
				dirs=(*/)
			fi
		fi
		if ((${#exdir[@]})); then
			if $nocwd; then
				exclude=(${exdir[@]/#/$d/})
			else
				exclude=(${exdir[@]})
			fi
		fi
		count=${#dirs[@]}
		for e in . .. ${exclude[@]+${exclude[@]}}; do
			for ((i = 0; i < count; i++)); do
				[[ ${dirs[i]%/} == ${e%/} ]] && unset 'dirs[i]'
			done
		done

		if [[ -z ${mindepth-} || $DEPTH -ge $mindepth ]]; then
			DIR="$d"
			$nocwd || CWD="${PWD#$ROOT/}"
			eval "$cmd" ${argv[@]+"${argv[@]}"} && err=0 || err=$?
			if ((err)); then
				$quiet || echo "redo: ${CWD:-$DIR}: $cmd: error $err" >&2
				$strict && exit $err
			fi
		fi

		((${#dirs[@]})) && traverse "${dirs[@]}"
		((DEPTH--))
		$nocwd || cd ..
	done
	return 0
}

function cleanup {
	rm -f "$script"
	exit 0
}

if [[ ${1-} == '--help' ]]; then
	cat <<-'EOF'
		usage: redo [--quiet] [--strict] [--follow] [--hidden] [--nocd]
		            [--mindepth N] [--maxdepth N] [--depth N]
		            [--] [+INCLUDE_GLOB ...] [-EXCLUDE_GLOB ...]
		            [+] [DIR ...] [-] [SCRIPT_OR_EXECUTABLE [ARG ...]]

		variables: DIR, CWD, COUNT, INDEX, DEPTH, RUNS
		           ROOT, RCOUNT, RINDEX
	EOF
	exit
fi
if [[ ${1-} == '--version' ]]; then
	echo "$0 $version"
	echo "Copyright (c) 2017-2024 Bernhard Waldbrunner"
	exit
fi

indir=()
exdir=()
dirs=()
argv=()
cmd=''
set=''
nocwd=false
strict=false
quiet=false
follow=false
opt=true
glob=true
file=true
export DIR='' CWD='' COUNT=0 RCOUNT=0 INDEX=0 RINDEX=0 DEPTH=0 RUNS=0 ROOT="$PWD"

for arg in "$@"; do
	if [[ -n $set ]]; then
		declare $set="$arg"
		set=''
		continue
	fi
	if $opt; then
		if [[ $arg == '--' ]]; then
			opt=false
			continue
		elif [[ $arg == '--nocwd' || $arg == '--nocd' ]]; then
			nocwd=true
			continue
		elif [[ $arg == '--follow' ]]; then
			follow=true
			continue
		elif [[ $arg == '--hidden' ]]; then
			shopt -s dotglob
			continue
		elif [[ $arg == '--depth' ]]; then
			set=depth
			continue
		elif [[ $arg == --depth=* ]]; then
			depth="${arg:8}"
			continue
		elif [[ $arg == '--mindepth' ]]; then
			set=mindepth
			continue
		elif [[ $arg == --mindepth=* ]]; then
			mindepth="${arg:11}"
			continue
		elif [[ $arg == '--maxdepth' ]]; then
			set=maxdepth
			continue
		elif [[ $arg == --maxdepth=* ]]; then
			maxdepth="${arg:11}"
			continue
		elif [[ $arg == '--strict' ]]; then
			strict=true
			continue
		elif [[ $arg == '--quiet' ]]; then
			quiet=true
			continue
		elif [[ ${arg:0:2} == '--' ]]; then
			echo "redo: unrecognized option '${arg:2}'" >&2
			exit 2
		fi
	fi
	if $glob; then
		if [[ $arg == '+' ]]; then
			glob=false
			opt=false
			continue
		elif [[ ${arg:0:1} == '-' ]]; then
			[[ $arg == */ ]] || arg+=/
			exdir+=("${arg:1}")
			continue
		elif [[ ${arg:0:1} == '+' ]]; then
			[[ $arg == */ ]] || arg+=/
			indir+=("${arg:1}")
			continue
		fi
	fi
	if $file; then
		if [[ $arg == '-' ]]; then
			glob=false
			opt=false
			file=false
			continue
		elif [[ -d $arg ]]; then
			if ! $follow && [[ -L $arg ]]; then
				$quiet || echo "redo: $arg: symlink not followed" >&2
			else
				dirs+=("$arg")
			fi
			glob=false
			opt=false
			continue
		elif [[ -f $arg ]]; then
			if [[ -x $arg ]]; then
				cmd="\"$(realpath -- "$arg")\""
			else
				read -r line < "$arg"
				if [[ ${line:0:2} == '#!' ]]; then
					cmd="${line:2}"
				else
					cmd="$SHELL"
				fi
				argv=("\"$(realpath -- "$arg")\"")
			fi
			glob=false
			opt=false
			file=false
			continue
		fi
	fi
	if [[ -z $cmd ]]; then
		cmd="$arg"
		glob=false
		opt=false
		file=false
	else
		argv+=("$arg")
	fi
done

if [[ -n $set ]]; then
	echo "redo: option '$set' requires an argument" >&2
	exit 2
fi
for opt in depth mindepth maxdepth; do
	if [[ -n ${!opt+1} ]] && [[ -z ${!opt} || ${!opt} =~ [^0-9] ]]; then
		echo "redo: option '$opt' requires an integer as argument" >&2
		exit 2
	fi
done
if [[ -n ${depth-} ]]; then
	mindepth=$depth
	maxdepth=$depth
fi

if ((${#dirs[@]} == 0)); then
	if ((${#indir[@]})); then
		dirs=(${indir[@]})
	else
		dirs=(*/)
	fi
	count=${#dirs[@]}
	for e in . .. ${exdir[@]+${exdir[@]}}; do
		for ((i = 0; i < count; i++)); do
			[[ ${dirs[i]%/} == ${e%/} ]] && unset 'dirs[i]'
		done
	done
fi

((${#dirs[@]})) || exit 0

if [[ -n $cmd ]]; then
	traverse "${dirs[@]}"
else
	script="$(mktemp -t redo)"
	trap cleanup INT
	read -r line
	if [[ ${line:0:2} == '#!' ]]; then
		cmd="${line:2}"
	else
		cmd="$SHELL"
		printf "%s\n" "$line" > "$script"
	fi
	cat >> "$script"
	argv=("\"$script\"")
	traverse "${dirs[@]}"
	cleanup
fi
