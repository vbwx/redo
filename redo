#!/bin/bash

version="2.3"

set -eu
shopt -s nullglob
IFS=$'\n'

function traverse {
	local INDEX=0
	local COUNT=$#
	((DEPTH)) || RCOUNT=$#
	[[ ${maxdepth-} && $DEPTH -eq $maxdepth ]] && return

	for d in "$@"; do
		((DEPTH)) || ((RINDEX++))
		((INDEX++))
		[[ $d != '/' ]] && d="${d%/}"
		if ! [[ -d $d ]]; then
			$quiet || echo "redo: ${CWD:+$CWD/}$d: no such directory" >&2
			continue
		fi
		! $follow && [[ -L $d ]] && continue
		if ! [[ -x $d && -r $d ]]; then
			$quiet || echo "redo: ${CWD:+$CWD/}$d: permission denied" >&2
			continue
		fi
		$nocwd || cd -- "$d"
		((DEPTH++))
		((RUNS++))

		if $nocwd; then
			if [[ ${indir-} ]]; then
				_dirs=()
				for e in "${indir[@]}"; do
					_dirs+=("$d"/$e)
				done
			else
				_dirs=("$d"/*/)
			fi
			exclude=()
			for e in "${exdir[@]}"; do
				exclude+=("$d"/$e)
			done
		else
			_dirs=(${indir[@]:-*/})
			exclude=(${exdir[@]})
		fi
		dirs=()
		for i in ${!_dirs[@]}; do
			for e in "${exclude[@]}"; do
				[[ "${_dirs[i]}" == "$e" ]] && continue 2
			done
			dirs+=("${_dirs[i]}")
		done

		if [[ ! ${mindepth-} || $DEPTH -ge $mindepth ]]; then
			DIR="$d"
			if $nocwd; then
				d="$d/"
			else
				CWD="${PWD#$ROOT/}"
				d=''
			fi
			FILES=0
			SUBDIRS=0
			for e in "$d"*; do
				[[ -d $e ]] && ((++SUBDIRS)) || ((++FILES))
			done

			shopt -u nullglob
			eval "$cmd" ${argv[@]+"${argv[@]}"} && err=0 || err=$?
			shopt -s nullglob
			if ((err)); then
				$hush || echo "redo: ${CWD:-$DIR}: $cmd: error $err" >&2
				$strict && exit $err
			fi
		fi

		[[ ${dirs-} ]] && traverse "${dirs[@]}"
		((DEPTH--))
		$nocwd || cd ..
	done
	return 0
}

function cleanup {
	rm -f "$script"
	exit 0
}

if [[ ${1-} == '--help' ]]; then
	cat <<-'EOF'
		usage: redo [--quiet] [--strict] [--follow] [--hidden] [--nocd]
		            [--mindepth N] [--maxdepth N] [--depth N]
		            [--] [+INCLUDE_GLOB ...] [-EXCLUDE_GLOB ...]
		            [+] [DIR ...] [-] [SCRIPT_OR_EXECUTABLE [ARG ...]]

		variables: DIR, CWD, COUNT, INDEX, DEPTH, RUNS, FILES, SUBDIRS,
		           ROOT, RCOUNT, RINDEX
	EOF
	exit
fi
if [[ ${1-} == '--version' ]]; then
	echo "$0 $version"
	echo "Copyright (c) 2017-2024 Bernhard Waldbrunner"
	exit
fi

indir=()
exdir=(./ ../)
dirs=()
argv=()
cmd=''
set=''
nocwd=false
strict=false
quiet=false
hush=false
follow=false
opt=true
glob=true
file=true
export COUNT RCOUNT INDEX RINDEX=0 DEPTH=0 RUNS=0 FILES SUBDIRS
export DIR CWD='' ROOT="$PWD"

for arg in "$@"; do
	if [[ $set ]]; then
		declare $set="$arg"
		set=''
		continue
	fi
	if $opt; then
		if [[ $arg == '--' ]]; then
			opt=false
			continue
		elif [[ $arg == '--nocwd' || $arg == '--nocd' ]]; then
			nocwd=true
			continue
		elif [[ $arg == '--follow' ]]; then
			follow=true
			continue
		elif [[ $arg == '--hidden' ]]; then
			shopt -s dotglob
			continue
		elif [[ $arg == '--depth' ]]; then
			set=depth
			continue
		elif [[ $arg == --depth=* ]]; then
			depth="${arg:8}"
			continue
		elif [[ $arg == '--mindepth' ]]; then
			set=mindepth
			continue
		elif [[ $arg == --mindepth=* ]]; then
			mindepth="${arg:11}"
			continue
		elif [[ $arg == '--maxdepth' ]]; then
			set=maxdepth
			continue
		elif [[ $arg == --maxdepth=* ]]; then
			maxdepth="${arg:11}"
			continue
		elif [[ $arg == '--strict' ]]; then
			strict=true
			continue
		elif [[ $arg == '--quiet' ]]; then
			quiet=true
			hush=true
			continue
		elif [[ ${arg:0:2} == '--' ]]; then
			echo "redo: unrecognized option '${arg:2}'" >&2
			exit 2
		fi
	fi
	if $glob; then
		if [[ $arg == [-+] ]]; then
			glob=false
			opt=false
			[[ $arg == '-' ]] && file=false
			continue
		elif [[ ${arg:0:1} == '-' ]]; then
			[[ $arg == */ ]] || arg+=/
			exdir+=("${arg:1}")
			continue
		elif [[ ${arg:0:1} == '+' ]]; then
			[[ $arg == */ ]] || arg+=/
			indir+=("${arg:1}")
			continue
		fi
	fi
	if $file; then
		if [[ $arg == '-' ]]; then
			glob=false
			opt=false
			file=false
			continue
		elif [[ -d $arg ]]; then
			if ! $follow && [[ -L $arg ]]; then
				$quiet || echo "redo: $arg: symlink not followed" >&2
			else
				dirs+=("$arg")
			fi
			glob=false
			opt=false
			continue
		elif [[ -f $arg ]]; then
			if [[ -x $arg ]]; then
				cmd="\"$(realpath -- "$arg")\""
			else
				read -r line < "$arg"
				if [[ ${line:0:2} == '#!' ]]; then
					cmd="${line:2}"
				else
					cmd="$SHELL"
				fi
				argv=("\"$(realpath -- "$arg")\"")
			fi
			glob=false
			opt=false
			file=false
			continue
		fi
	fi
	if [[ $cmd ]]; then
		argv+=("$arg")
	else
		cmd="$arg"
		glob=false
		opt=false
		file=false
		hush=true
	fi
done

if [[ $set ]]; then
	echo "redo: option '$set' requires an argument" >&2
	exit 2
fi
for opt in depth mindepth maxdepth; do
	if [[ ${!opt+1} ]] && [[ ! ${!opt} || ${!opt} =~ [^0-9] ]]; then
		echo "redo: option '$opt' requires an integer as argument" >&2
		exit 2
	fi
done
if [[ ${depth-} ]]; then
	mindepth=$depth
	maxdepth=$depth
fi

if [[ ! ${dirs-} ]]; then
	_dirs=(${indir[@]:-*/})
	for i in ${!_dirs[@]}; do
		for e in ${exdir[@]}; do
			[[ "${_dirs[i]}" == "$e" ]] && continue 2
		done
		dirs+=("${_dirs[i]}")
	done
	[[ ${dirs-} ]] || exit 0
fi

if [[ $cmd ]]; then
	traverse "${dirs[@]}"
else
	script="$(mktemp -t redo)"
	trap cleanup INT
	read -r line
	if [[ ${line:0:2} == '#!' ]]; then
		cmd="${line:2}"
	else
		cmd="$SHELL"
		printf "%s\n" "$line" > "$script"
	fi
	cat >> "$script"
	argv=("\"$script\"")
	hush=true
	traverse "${dirs[@]}"
	cleanup
fi
