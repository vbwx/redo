#!/bin/bash

version="2.1"

set -eu
shopt -s nullglob
IFS=$'\t\n'

function traverse {
	INDEX=0
	COUNT=$#
	((DEPTH)) || RCOUNT=$#
	[[ -n ${maxdepth-} && $DEPTH -eq $maxdepth ]] && return

	for d in "$@"; do
		((DEPTH)) || ((RINDEX++))
		((INDEX++))
		d="${d%/}"
		if ! [[ -d $d ]]; then
			$quiet || echo "redo: ${CWD:+$CWD/}$d: no such directory" >&2
			continue
		fi
		! $follow && [[ -L $d ]] && continue
		if ! [[ -x $d && -r $d ]]; then
			$quiet || echo "redo: ${CWD:+$CWD/}$d: permission denied" >&2
			continue
		fi
		$nocwd || cd "./$d"
		((DEPTH++))
		((RUNS++))

		if ((${#indir[@]})); then
			if $nocwd; then
				dirs=(${indir[@]/#/$d/})
			else
				dirs=(${indir[@]})
			fi
		else
			if $nocwd; then
				dirs=("$d"/*/)
			else
				dirs=(*/)
			fi
		fi
		if ((${#exdir[@]})); then
			if $nocwd; then
				exclude=(${exdir[@]/#/$d/})
			else
				exclude=(${exdir[@]})
			fi
		fi
		count=${#dirs[@]}
		for e in . .. ${exclude[@]+${exclude[@]}}; do
			i=0
			while ((i < count)); do
				[[ ${dirs[i]%/} == ${e%/} ]] && unset 'dirs[i]'
				((i++))
			done
		done

		if [[ -z ${mindepth-} || $DEPTH -ge $mindepth ]]; then
			DIR="$d"
			if ! $nocwd; then
				[[ $d == '.' ]] && CWD='.' || CWD="${PWD#*$ROOT/}"
			fi
			eval "$cmd" ${argv[@]+"${argv[@]}"} && err=0 || err=$?
			if ((err)); then
				$quiet || echo "redo: ${c:-$exe}: error $err" >&2
				$strict && exit $err
			fi
		fi

		((${#dirs[@]})) && traverse "${dirs[@]}"
		((DEPTH--))
		$nocwd || cd ..
	done
}

function cleanup {
	rm -f "$script"
	exit
}

if [[ ${1-} == '--help' ]]; then
	cat <<-'EOF'
		usage: redo [--quiet] [--strict] [--follow] [--nocd]
		            [--mindepth N] [--maxdepth N] [--depth N]
		            [--] [+INCLUDE_GLOB ...] [-EXCLUDE_GLOB ...]
		            [+] [DIR ...] [-] [SCRIPT_OR_EXECUTABLE [ARG ...]]
		variables: DIR, CWD, COUNT, INDEX, DEPTH, RUNS
		           ROOT, RCOUNT, RINDEX
	EOF
	exit
fi
if [[ ${1-} == '--version' ]]; then
	echo "$0 $version"
	echo "Copyright 2017-2024 Bernhard Waldbrunner"
	exit
fi

indir=()
exdir=()
dirs=()
argv=()
cmd=''
nocwd=false
strict=false
quiet=false
follow=false
opt=true
glob=true
file=true
export DIR=. CWD=. COUNT=0 RCOUNT=0 INDEX=0 RINDEX=0 DEPTH=0 RUNS=0 ROOT="$PWD"

for arg in "$@"; do
	if [[ -n ${set-} ]]; then
		declare $set="$arg"
		set=''
	else
		if $opt && [[ $arg == '--' ]]; then
			opt=false
		elif $opt && [[ $arg == '--nocwd' || $arg == '--nocd' ]]; then
			nocwd=true
		elif $opt && [[ $arg == '--follow' ]]; then
			follow=true
		elif $opt && [[ $arg == '--depth' ]]; then
			set=depth
		elif $opt && [[ $arg == --depth=* ]]; then
			depth="${arg:8}"
		elif $opt && [[ $arg == '--mindepth' ]]; then
			set=mindepth
		elif $opt && [[ $arg == --mindepth=* ]]; then
			mindepth="${arg:8}"
		elif $opt && [[ $arg == '--maxdepth' ]]; then
			set=maxdepth
		elif $opt && [[ $arg == --maxdepth=* ]]; then
			maxdepth="${arg:8}"
		elif $opt && [[ $arg == '--strict' ]]; then
			strict=true
		elif $opt && [[ $arg == '--quiet' ]]; then
			quiet=true
		elif $opt && [[ ${arg:0:2} == '--' ]]; then
			echo "redo: unrecognized option '${arg:2}'" >&2
			exit 2
		elif $glob && [[ $arg == '+' ]]; then
			glob=false
			opt=false
		elif $file && [[ $arg == '-' ]]; then
			glob=false
			opt=false
			file=false
		elif $glob && [[ ${arg:0:1} == '-' ]]; then
			[[ $arg == */ ]] || arg+=/
			exdir+=("${arg:1}")
		elif $glob && [[ ${arg:0:1} == '+' ]]; then
			[[ $arg == */ ]] || arg+=/
			indir+=("${arg:1}")
		elif $file && [[ -d $arg ]]; then
			if ! $follow && [[ -L $arg ]]; then
				$quiet || echo "redo: $arg: symlink not followed" >&2
			else
				dirs+=("$arg")
			fi
			glob=false
			opt=false
		elif $file && [[ -f $arg ]]; then
			if [[ -x $arg ]]; then
				cmd="\"$(realpath "$arg")\""
			else
				read -r line < "$arg"
				if [[ ${line:0:2} == '#!' ]]; then
					cmd="${line:2}"
				else
					cmd="$SHELL"
				fi
				argv=("\"$(realpath "$arg")\"")
			fi
			glob=false
			opt=false
			file=false
		elif [[ -z $cmd ]]; then
			cmd="$arg"
			glob=false
			opt=false
			file=false
		else
			argv+=("$arg")
		fi
	fi
done

if [[ -n ${set-} ]]; then
	echo "redo: option '$set' requires an argument" >&2
	exit 2
fi
for opt in depth mindepth maxdepth; do
	if [[ -n ${!opt+1} ]] && [[ -z ${!opt} || ${!opt} =~ [^0-9] ]]; then
		echo "redo: option '$opt' requires an integer as argument" >&2
		exit 2
	fi
done
if [[ -n ${depth-} ]]; then
	mindepth=$depth
	maxdepth=$depth
fi

if ! ((${#dirs[@]})); then
	if ((${#indir[@]})); then
		dirs=(${indir[@]})
	else
		dirs=(*/)
	fi
	count=${#dirs[@]}
	for e in . .. ${exdir[@]+${exdir[@]}}; do
		i=0
		while ((i < count)); do
			[[ ${dirs[i]%/} == ${e%/} ]] && unset 'dirs[i]'
			((i++))
		done
	done
fi

((${#dirs[@]})) || exit

if [[ -n $cmd ]]; then
	traverse "${dirs[@]}"
else
	script="$(mktemp -t redo)"
	trap cleanup INT
	read -r line
	if [[ ${line:0:2} == '#!' ]]; then
		cmd="${line:2}"
	else
		cmd="$SHELL"
		printf "%s\n" "$line" > "$script"
	fi
	cat >> "$script"
	argv=("$script")
	traverse "${dirs[@]}"
	cleanup
fi
